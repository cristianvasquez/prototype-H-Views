import { List, Map } from 'immutable';
import * as C from '../../util/Consts';
import * as E from '../Expressions';
import { Bindings } from '../Types';
export declare type SPARQLFunction = RegularFunc | SpecialFunc;
export interface RegularFunc {
    functionClass: 'regular';
    arity: number | number[];
    apply: E.SimpleApplication;
}
export interface SpecialFunc {
    functionClass: 'special';
    arity: number;
    apply: E.SpecialApplication;
}
export interface Definition {
    arity: number | number[];
    overloads: OverloadMap;
}
export interface SpecialDefinition {
    arity: number;
    constructor: new () => SpecialFunctionAsync;
}
export declare type ArgumentType = 'term' | E.TermType | C.Type;
export declare type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;
export declare class RegularFunction implements RegularFunc {
    operator: C.Operator;
    functionClass: 'regular';
    arity: number | number[];
    private overloadMap;
    constructor(operator: C.Operator, definition: Definition);
    apply(args: E.TermExpression[]): E.TermExpression;
    private _monomorph;
}
export declare abstract class SpecialFunctionAsync implements SpecialFunc {
    functionClass: 'special';
    abstract arity: number;
    abstract operator: C.SpecialOperator;
    abstract apply(args: E.Expression[], mapping: Bindings, evaluate: (e: E.Expression, mapping: Bindings) => Promise<E.TermExpression>): Promise<E.TermExpression>;
}
