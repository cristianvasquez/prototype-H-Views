{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../lib/core/functions/types.ts"],"names":[],"mappings":";;AAAA,yCAAsC;AAKtC,8CAAyD;AA8DzD,MAAa,eAAe;IAK1B,YAAmB,QAAoB,EAAE,UAAsB;QAA5C,aAAQ,GAAR,QAAQ,CAAY;QAJvC,kBAAa,GAAc,SAAS,CAAC;QAKnC,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;QAC9B,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,SAAS,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,IAAwB;QAC5B,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,IAAI,EAAE;YAAE,MAAM,IAAI,6BAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;SAAE;QACnE,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAED,uBAAuB;IACf,UAAU,CAAC,IAAwB;QACzC,kCAAkC;QAClC,MAAM,QAAQ,GAAG,gBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClE,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC;eAChC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,gBAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAmB,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;eACzE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,gBAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC7D,CAAC;CACF;AAzBD,0CAyBC;AAED,+EAA+E;AAC/E;;;;;;;;;;;;;;GAcG;AAEH,MAAsB,oBAAoB;IAA1C;QACE,kBAAa,GAAc,SAAS,CAAC;IAUvC,CAAC;CAAA;AAXD,oDAWC","sourcesContent":["import { List, Map } from 'immutable';\n\nimport * as C from '../../util/Consts';\nimport * as E from '../Expressions';\n\nimport { InvalidArgumentTypes } from '../../util/Errors';\nimport { Bindings } from '../Types';\n\n// ----------------------------------------------------------------------------\n// Types\n// ----------------------------------------------------------------------------\n\nexport type SPARQLFunction = RegularFunc | SpecialFunc;\nexport interface RegularFunc {\n  functionClass: 'regular';\n  arity: number | number[];\n  apply: E.SimpleApplication;\n}\nexport interface SpecialFunc {\n  functionClass: 'special';\n  arity: number;\n  apply: E.SpecialApplication;\n}\n\nexport interface Definition {\n  arity: number | number[];\n  overloads: OverloadMap;\n}\n\nexport interface SpecialDefinition {\n  arity: number;\n  constructor: new () => SpecialFunctionAsync;\n}\n\n// Argument Types and their specificity ---------------------------------------\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.Type;\n\n// Regular Functions ----------------------------------------------------------\n\n/*\n * Regular functions have relatively simple behaviour that should always be\n * evaluated sync.\n *\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * Note: functions that have multiple arities do not belong in this category.\n * Eg: BNODE.\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\n\n// Maps argument types on their specific implementation.\nexport type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;\n\nexport class RegularFunction implements RegularFunc {\n  functionClass: 'regular' = 'regular';\n  arity: number | number[];\n  private overloadMap: OverloadMap;\n\n  constructor(public operator: C.Operator, definition: Definition) {\n    this.arity = definition.arity;\n    this.overloadMap = definition.overloads;\n  }\n\n  apply(args: E.TermExpression[]): E.TermExpression {\n    const func = this._monomorph(args);\n    if (!func) { throw new InvalidArgumentTypes(args, this.operator); }\n    return func(args);\n  }\n\n  // TODO: Clean up a bit\n  private _monomorph(args: E.TermExpression[]): E.SimpleApplication {\n    // tslint:disable-next-line:no-any\n    const argTypes = List(args.map((a: any) => a.type || a.termType));\n    const arity = args.length;\n    return this.overloadMap.get(argTypes)\n      || this.overloadMap.get(List(args.map((a: E.TermExpression) => a.termType)))\n      || this.overloadMap.get(List(Array(arity).fill('term')));\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/*\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\n\nexport abstract class SpecialFunctionAsync implements SpecialFunc {\n  functionClass: 'special' = 'special';\n  abstract arity: number;\n  abstract operator: C.SpecialOperator;\n\n  abstract apply(\n    args: E.Expression[],\n    mapping: Bindings,\n    evaluate: (e: E.Expression, mapping: Bindings) => Promise<E.TermExpression>,\n  ): Promise<E.TermExpression>;\n\n}\n"]}